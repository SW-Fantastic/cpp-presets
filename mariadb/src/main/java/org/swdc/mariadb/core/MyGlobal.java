// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.swdc.mariadb.core;

import org.swdc.mariadb.core.global.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class MyGlobal extends org.swdc.mariadb.conf.MyGlobalConfigure {
    static { Loader.load(); }

// Parsed from my_global.h

/*
   Copyright (c) 2001, 2013, Oracle and/or its affiliates.
   Copyright (c) 2009, 2022, MariaDB Corporation.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA */

/* This is the include file that should be included 'first' in every C file. */

// #ifndef MY_GLOBAL_INCLUDED
// #define MY_GLOBAL_INCLUDED

/*
  MDEV-25602 Deprecate __WIN__ symbol.
*/
// #if defined (_MSC_VER) && !defined(__clang__)
// #pragma deprecated("__WIN__")
// #elif defined (__GNUC__)
// #pragma GCC poison __WIN__
// #endif

// #if defined(_MSC_VER) && !defined(__clang__)
/*
  Following functions have bugs, when used with UTF-8 active codepage.
  #include <winservice.h> will use the non-buggy wrappers
*/
// #pragma deprecated("CreateServiceA", "OpenServiceA", "ChangeServiceConfigA")
// #endif

/*
  InnoDB depends on some MySQL internals which other plugins should not
  need.  This is because of InnoDB's foreign key support, "safe" binlog
  truncation, and other similar legacy features.

  We define accessors for these internals unconditionally, but do not
  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for
  InnoDB's use.
*/
// #define INNODB_COMPATIBILITY_HOOKS

// #ifdef __CYGWIN__
/* We use a Unix API, so pretend it's not Windows */
// #undef WIN
// #undef WIN32
// #undef _WIN
// #undef _WIN32
// #undef _WIN64
// #undef _WIN32
// #undef __WIN32__
// #define HAVE_ERRNO_AS_DEFINE
// #define _POSIX_MONOTONIC_CLOCK
// #define _POSIX_THREAD_CPUTIME
// #endif /* __CYGWIN__ */

// #if defined(__OpenBSD__) && (OpenBSD >= 200411)
// #define HAVE_ERRNO_AS_DEFINE
// #endif

// #if defined(i386) && !defined(__i386__)
// #define __i386__
// #endif

/* Macros to make switching between C and C++ mode easier */
// #ifdef __cplusplus
// #define C_MODE_START    extern "C" {
// #define C_MODE_END	}
// #else
// #define C_MODE_START
// #define C_MODE_END
// #endif

// #ifdef __cplusplus
// #define CPP_UNNAMED_NS_START  namespace {
// #define CPP_UNNAMED_NS_END    }
// #endif

// #include <my_config.h>

// #ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
// #define HAVE_PSI_INTERFACE
// #endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */

/* Make it easier to add conditional code in _expressions_ */
// #ifdef _WIN32
// #define IF_WIN(A,B) A
// #else
// #define IF_WIN(A,B) B
// #endif

// #ifdef EMBEDDED_LIBRARY
// #define IF_EMBEDDED(A,B) A
// #else
// #define IF_EMBEDDED(A,B) B
// #endif

// #ifdef WITH_PARTITION_STORAGE_ENGINE
// #define IF_PARTITIONING(A,B) A
// #else
// #define IF_PARTITIONING(A,B) B
// #endif

// #if defined (_WIN32)
/*
 off_t is 32 bit long. We do not use C runtime functions
 with off_t but native Win32 file IO APIs, that work with
 64 bit offsets.
*/
// #undef SIZEOF_OFF_T
public static final int SIZEOF_OFF_T = 8;

/*
 Prevent inclusion of  Windows GDI headers - they define symbol
 ERROR that conflicts with mysql headers.
*/
// #ifndef NOGDI
// #define NOGDI
// #endif

/* Include common headers.*/
// #include <io.h>       /* access(), chmod() */
// #include <process.h>  /* getpid() */

// #define sleep(a) Sleep((a)*1000)

/* Define missing access() modes. */
public static final int F_OK = 0;
public static final int W_OK = 2;
public static final int R_OK = 4;                        /* Test for read permission.  */

/* Define missing file locking constants. */
public static final int F_RDLCK = 1;
public static final int F_WRLCK = 2;
public static final int F_UNLCK = 3;
public static final int F_TO_EOF = 0x3FFFFFFF;

// #endif /* _WIN32*/

/*
  The macros below are used to allow build of Universal/fat binaries of
  MySQL and MySQL applications under darwin. 
*/
// #if defined(__APPLE__) && defined(__MACH__)
// #  undef SIZEOF_CHARP 
// #  undef SIZEOF_INT 
// #  undef SIZEOF_LONG 
// #  undef SIZEOF_LONG_LONG 
// #  undef SIZEOF_OFF_T 
// #  undef WORDS_BIGENDIAN
public static final int SIZEOF_INT = 4;
public static final int SIZEOF_LONG_LONG = 8;
// #  if defined(__i386__) || defined(__ppc__)
public static final int SIZEOF_CHARP = 4;
public static final int SIZEOF_LONG = 4;
// #  elif defined(__x86_64__) || defined(__ppc64__) || defined(__aarch64__) || defined(__arm64__)
// #  else
// #    error Building FAT binary for an unknown architecture.
// #  endif
// #  if defined(__ppc__) || defined(__ppc64__)
// #    define WORDS_BIGENDIAN
// #  endif
// #endif /* defined(__APPLE__) && defined(__MACH__) */


/*
  The macros below are borrowed from include/linux/compiler.h in the
  Linux kernel. Use them to indicate the likelihood of the truthfulness
  of a condition. This serves two purposes - newer versions of gcc will be
  able to optimize for branch predication, which could yield siginficant
  performance gains in frequently executed sections of the code, and the
  other reason to use them is for documentation
*/

// #if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
// #define __builtin_expect(x, expected_value) (x)
// #endif

/* Fix problem with S_ISLNK() on Linux */
// #if defined(TARGET_OS_LINUX) || defined(__GLIBC__)
// #undef  _GNU_SOURCE
public static final int _GNU_SOURCE = 1;
// #endif

/*
  Temporary solution to solve bug#7156. Include "sys/types.h" before
  the thread headers, else the function madvise() will not be defined
*/
// #if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )
// #include <sys/types.h>
// #endif

public static final int __EXTENSIONS__ = 1;	/* We want some extension */
// #ifndef __STDC_EXT__
public static final int __STDC_EXT__ = 1;          /* To get large file support on hpux */
// #endif

/*
  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document

    System Interfaces and Headers, Issue 5

  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,
  but apparently other systems (namely FreeBSD) don't agree.

  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.
  Furthermore, it tests that if a program requires older standard
  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be
  run on a new compiler (that defines _STDC_C99) and issues an #error.
  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600
  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.

  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while
  C++ compiler does not!

  So, in a desperate attempt to get correct prototypes for both
  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500
  depending on the compiler's announced C standard support.

  Cleaner solutions are welcome.
*/
// #ifdef __sun
// #if __STDC_VERSION__ - 0 >= 199901L
public static final int _XOPEN_SOURCE = 600;
// #else
// #endif
// #endif


// #ifdef _AIX
/*
  AIX includes inttypes.h from sys/types.h
  Explicitly request format macros before the first inclusion of inttypes.h
*/
// #if !defined(__STDC_FORMAT_MACROS)
// #define __STDC_FORMAT_MACROS
// #endif  // !defined(__STDC_FORMAT_MACROS)
// #endif


// #if !defined(_WIN32)
// #ifndef _POSIX_PTHREAD_SEMANTICS
// #define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */
// #endif

// #if !defined(SCO)
public static final int _REENTRANT =	1;	/* Some thread libraries require this */
// #endif
// #if !defined(_THREAD_SAFE) && !defined(_AIX)
// #define _THREAD_SAFE            /* Required for OSF1 */
// #endif
// #if defined(HPUX10) || defined(HPUX11)			/* HPUX needs this, signal.h bug */
// #include <pthread.h>
// #else
// #include <pthread.h>		/* AIX must have this included first */
// #endif
// #if !defined(SCO) && !defined(_REENTRANT)	/* Threads requires reentrant code */
// #endif
// #endif /* !defined(_WIN32) */

/* gcc/egcs issues */

// #if defined(__GNUC) && defined(__EXCEPTIONS)
// #error "Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile"
// #endif

// #if defined(_lint) && !defined(lint)
// #define lint
// #endif

// #ifndef stdin
// #include <stdio.h>
// #endif
// #include <stdarg.h>
// #ifdef HAVE_STDLIB_H
// #include <stdlib.h>
// #endif
// #ifdef HAVE_STDDEF_H
// #include <stddef.h>
// #endif

// #include <math.h>
// #ifdef HAVE_LIMITS_H
// #include <limits.h>
// #endif
// #ifdef HAVE_FLOAT_H
// #include <float.h>
// #endif
// #ifdef HAVE_FENV_H
// #include <fenv.h> /* For fesetround() */
// #endif

// #ifdef HAVE_SYS_TYPES_H
// #include <sys/types.h>
// #endif

// #ifdef HAVE_FCNTL_H
// #include <fcntl.h>
// #endif
// #ifdef HAVE_SYS_STAT_H
// #include <sys/stat.h>
// #endif
// #if TIME_WITH_SYS_TIME
// # include <sys/time.h>
// # include <time.h>
// #else
// # if HAVE_SYS_TIME_H
// #  include <sys/time.h>
// # else
// #  include <time.h>
// # endif
// #endif /* TIME_WITH_SYS_TIME */
// #ifdef HAVE_UNISTD_H
// #include <unistd.h>
// #endif

// #include <errno.h>				/* Recommended by debian */
/* We need the following to go around a problem with openssl on solaris */
// #if defined(HAVE_CRYPT_H)
// #include <crypt.h>
// #endif

/* Add checking if we are using likely/unlikely wrong */
// #ifdef CHECK_UNLIKELY 


// #define likely(A) ((A) ? (my_likely_ok(__FILE__, __LINE__),1) : (my_likely_fail(__FILE__, __LINE__), 0))
// #define unlikely(A) ((A) ? (my_likely_fail(__FILE__, __LINE__),1) : (my_likely_ok(__FILE__, __LINE__), 0))
/*
  These macros should be used when the check fails often when running benchmarks but
  we know for sure that the check is correct in a production environment
*/
// #define checked_likely(A) (A)
// #define checked_unlikely(A) (A)
// #else
/**
  The semantics of builtin_expect() are that
  1) its two arguments are long
  2) it's likely that they are ==
  Those of our likely(x) are that x can be bool/int/longlong/pointer.
*/

// #define likely(x)	__builtin_expect(((x) != 0),1)
// #define unlikely(x)	__builtin_expect(((x) != 0),0)
// #define checked_likely(x) likely(x)
// #define checked_unlikely(x) unlikely(x)
// #endif /* CHECK_UNLIKELY */

/*
  A lot of our programs uses asserts, so better to always include it
  This also fixes a problem when people uses DBUG_ASSERT without including
  assert.h
*/
// #include <assert.h>

/* an assert that works at compile-time. only for constant expression */
// #ifdef _some_old_compiler_that_does_not_understand_the_construct_below_
// #define compile_time_assert(X)  do { } while(0)
// #else
// #define compile_time_assert(X)
//   do
//   {
//     typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused));
//   } while(0)
// #endif

/* Go around some bugs in different OS and compilers */
// #if defined (HPUX11) && defined(_LARGEFILE_SOURCE)
// #ifndef _LARGEFILE64_SOURCE
// #define _LARGEFILE64_SOURCE
// #endif
// #endif

// #if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)
// #include <sys/stream.h>		/* HPUX 10.20 defines ulong here. UGLY !!! */
// #define HAVE_ULONG
// #endif
// #if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)
/* Fix bug in setrlimit */
// #undef setrlimit
// #define setrlimit cma_setrlimit64
// #endif
/* Declare madvise where it is not declared for C++, like Solaris */
// #if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)

// #endif
// #ifdef HAVE_SYS_MMAN_H
// #include <sys/mman.h>
// #endif
/** FreeBSD equivalent */
// #if defined(MADV_CORE) && !defined(MADV_DODUMP)
// #define MADV_DODUMP MADV_CORE
// #define MADV_DONTDUMP MADV_NOCORE
// #define DODUMP_STR "MADV_CORE"
// #define DONTDUMP_STR "MADV_NOCORE"
// #else
// #define DODUMP_STR "MADV_DODUMP"
// #define DONTDUMP_STR "MADV_DONTDUMP"
// #endif


// #define QUOTE_ARG(x)		#x	/* Quote argument (before cpp) */
// #define STRINGIFY_ARG(x) QUOTE_ARG(x)	/* Quote argument, after cpp */

/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */
// #ifdef I_AM_PARANOID
// #define DONT_ALLOW_USER_CHANGE 1
// #define DONT_USE_MYSQL_PWD 1
// #endif

/* Does the system remember a signal handler after a signal ? */
// #if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)
// #define SIGNAL_HANDLER_RESET_ON_DELIVERY
// #endif

/* don't assume that STDERR_FILENO is 2, mysqld can freopen */
// #undef STDERR_FILENO

// #ifndef SO_EXT
// #ifdef _WIN32
// #define SO_EXT ".dll"
// #else
// #define SO_EXT ".so"
// #endif
// #endif

/*
   Suppress uninitialized variable warning without generating code.
*/
// #if defined(__GNUC__)
/* GCC specific self-initialization which inhibits the warning. */
// #define UNINIT_VAR(x) x= x
// #elif defined(_lint) || defined(FORCE_INIT_OF_VARS)
// #define UNINIT_VAR(x) x= 0
// #else
// #define UNINIT_VAR(x) x
// #endif

/* This is only to be used when resetting variables in a class constructor */
// #if defined(_lint) || defined(FORCE_INIT_OF_VARS)
// #define LINT_INIT(x) x= 0
// #else
// #define LINT_INIT(x)
// #endif

// #if !defined(HAVE_UINT)
// #undef HAVE_UINT
// #define HAVE_UINT
// #endif

// #define swap_variables(t, a, b) do { t dummy; dummy= a; a= b; b= dummy; } while(0)
// #define MY_TEST(a) ((a) ? 1 : 0)
// #define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)
// #define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)
// #define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))
// #define test_all_bits(a,b) (((a) & (b)) == (b))
// #define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))

/* Define some general constants */
// #ifndef TRUE
// #define TRUE		(1)	/* Logical true */
// #define FALSE		(0)	/* Logical false */
// #endif

// #include <my_compiler.h>
// #include <my_alloca.h>

/*
  Wen using the embedded library, users might run into link problems,
  duplicate declaration of __cxa_pure_virtual, solved by declaring it a
  weak symbol.
*/
// #if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)
// #endif

/* The DBUG_ON flag always takes precedence over default DBUG_OFF */
// #if defined(DBUG_ON) && defined(DBUG_OFF)
// #undef DBUG_OFF
// #endif

/* We might be forced to turn debug off, if not turned off already */
// #if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)
// #  define DBUG_OFF
// #  ifdef DBUG_ON
// #    undef DBUG_ON
// #  endif
// #endif

// #ifdef DBUG_OFF
// #endif

/* Some types that is different between systems */		/* File descriptor */
// #ifdef _WIN32
// #else	/* File descriptor for sockets */
// #define INVALID_SOCKET -1
// #endif
/* Type for functions that handles signals */
// #define sig_handler RETSIGTYPE
// #if defined(__GNUC__) && !defined(_lint)		/* Mixed prototypes can take char */		/* Mixed prototypes can take char */		/* Mixed prototypes can take char */		/* Mixed prototypes can take short int */		/* Mixed prototypes can take float */
// #else		/* Mixed prototypes can't take char */		/* Mixed prototypes can't take char */		/* Mixed prototypes can't take char */		/* Mixed prototypes can't take short int */		/* Mixed prototypes can't take float */
// #endif
// Targeting global\qsort_cmp2.java


// #define qsort_t RETQSORTTYPE	/* Broken GCC can't handle typedef !!!! */
// #ifdef HAVE_SYS_SOCKET_H
// #include <sys/socket.h>
// #endif

// #ifndef SOCKOPT_OPTLEN_TYPE
// #define SOCKOPT_OPTLEN_TYPE size_socket
// #endif

/* file create flags */

// #ifndef O_SHARE			/* Probably not windows */
public static final int O_SHARE =		0;	/* Flag to my_open for shared files */
// #ifndef O_BINARY
public static final int O_BINARY =	0;	/* Flag to my_open for binary files */
// #endif
// #ifndef FILE_BINARY
public static final int FILE_BINARY =	O_BINARY; /* Flag to my_fopen for binary streams */
// #endif
// #ifdef HAVE_FCNTL
// #define HAVE_FCNTL_LOCK	/* Param to lockf() to lock rest of file */
// #endif
// #endif /* O_SHARE */

// #ifndef O_SEQUENTIAL
public static final int O_SEQUENTIAL =	0;
// #endif
// #ifndef O_SHORT_LIVED
public static final int O_SHORT_LIVED =	0;
// #endif
// #ifndef O_NOFOLLOW
public static final int O_NOFOLLOW =      0;
// #endif
// #ifndef O_CLOEXEC
public static final int O_CLOEXEC =       0;
// #endif
// #ifdef __GLIBC__
public static final String STR_O_CLOEXEC = "e";
// #else
// #endif
// #ifndef SOCK_CLOEXEC
public static final int SOCK_CLOEXEC =    0;
// #else
// #define HAVE_SOCK_CLOEXEC
// #endif
// #ifndef O_TEXT
public static final int O_TEXT = 0;
// #endif

/* additional file share flags for win32 */
// #ifdef _WIN32
public static final int _SH_DENYRWD =     0x110;    /* deny read/write mode & delete */
public static final int _SH_DENYWRD =     0x120;    /* deny write mode & delete      */
public static final int _SH_DENYRDD =     0x130;    /* deny read mode & delete       */
public static final int _SH_DENYDEL =     0x140;    /* deny delete only              */
// #endif /* _WIN32 */


/* General constants */
public static final int FN_LEN =		256;	/* Max file name len */
public static final int FN_HEADLEN =	253;	/* Max length of filepart of file name */
public static final int FN_EXTLEN =	20;	/* Max length of extension (part of FN_LEN) */
public static final int FN_REFLEN =	512;	/* Max length of full path-name */
public static final int FN_EXTCHAR =	'.';
public static final int FN_HOMELIB =	'~';	/* ~/ is used as abbrev for home dir */
public static final int FN_CURLIB =	'.';	/* ./ is used as abbrev for current dir */
public static final String FN_PARENTDIR =	"..";	/* Parent directory; Must be a string */

// #ifdef _WIN32
// #define FN_LIBCHAR	'\\'
// #define FN_LIBCHAR2	'/'
// #define FN_DIRSEP       "/\\"               /* Valid directory separators */
// #define FN_EXEEXT   ".exe"
// #define FN_SOEXT    ".dll"
// #define FN_ROOTDIR	"\\"
// #define FN_DEVCHAR	':'
// #define FN_NETWORK_DRIVES	/* Uses \\ to indicate network drives */
// #define FN_NO_CASE_SENCE	/* Files are not case-sensitive */
// #else
// #define FN_LIBCHAR	'/'
// #define FN_LIBCHAR2	'/'
// #define FN_DIRSEP       "/"     /* Valid directory separators */
// #define FN_EXEEXT   ""
// #define FN_SOEXT    ".so"
// #define FN_ROOTDIR	"/"
// #endif

/* 
  MY_FILE_MIN is  Windows speciality and is used to quickly detect
  the mismatch of CRT and mysys file IO usage on Windows at runtime.
  CRT file descriptors can be in the range 0-2047, whereas descriptors returned
  by my_open() will start with 2048. If a file descriptor with value less then
  MY_FILE_MIN is passed to mysys IO function, chances are it stems from
  open()/fileno() and not my_open()/my_fileno.

  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN
  is logically 0.
*/

// #ifdef _WIN32
// #define MY_FILE_MIN  2048
// #else
// #define MY_FILE_MIN  0
// #endif

/* 
  MY_NFILE is the default size of my_file_info array.

  It is larger on Windows, because it all file handles are stored in my_file_info
  Default size is 16384 and this should be enough for most cases.If it is not 
  enough, --max-open-files with larger value can be used.

  For Posix , my_file_info array is only used to store filenames for
  error reporting and its size is not a limitation for number of open files.
*/ 
// #ifdef _WIN32
// #define MY_NFILE (16384 + MY_FILE_MIN)
// #else
// #define MY_NFILE 64
// #endif

// #ifndef OS_FILE_LIMIT
// #define OS_FILE_LIMIT	UINT_MAX
// #endif

/*
  Io buffer size; Must be a power of 2 and a multiple of 512. May be
  smaller what the disk page size. This influences the speed of the
  isam btree library. eg to big to slow.
  4096 is a common block size on SSDs.
*/
public static final int IO_SIZE =			4096;
/*
  How much overhead does malloc have. The code often allocates
  something like 1024-MALLOC_OVERHEAD bytes
*/
public static final int MALLOC_OVERHEAD = 8;

	/* get memory in huncs */
// #define ONCE_ALLOC_INIT		(uint) 4096
	/* Typical record cache */
// #define RECORD_CACHE_SIZE	(uint) (128*1024)
	/* Typical key cache */
// #define KEY_CACHE_SIZE		(uint) (128L*1024L*1024L)
	/* Default size of a key cache block  */
// #define KEY_CACHE_BLOCK_SIZE	(uint) 1024

	/* Some things that this system doesn't have */

// #ifdef _WIN32
// #define NO_DIR_LIBRARY		/* Not standard dir-library */
// #endif

/* Some defines of functions for portability */

// #undef remove		/* Crashes MySQL on SCO 5.0.0 */
// #ifndef _WIN32
// #define closesocket(A)	close(A)
// #endif

// #if defined(_MSC_VER)
// #if !defined(_WIN64)

// #define ulonglong2double my_ulonglong2double
// #define my_off_t2double  my_ulonglong2double
// #endif /* _WIN64 */

// #define double2ulonglong my_double2ulonglong
// #endif

// #ifndef ulonglong2double
// #define ulonglong2double(A) ((double) (ulonglong) (A))
// #define my_off_t2double(A)  ((double) (my_off_t) (A))
// #endif
// #ifndef double2ulonglong
// #define double2ulonglong(A) ((ulonglong) (double) (A))
// #endif

// #ifndef offsetof
// #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
// #endif
// #define ulong_to_double(X) ((double) (ulong) (X))

// #ifndef STACK_DIRECTION
// #error "please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS"
// #endif

// #if !defined(HAVE_STRTOK_R)
// #define strtok_r(A,B,C) strtok((A),(B))
// #endif

// #if SIZEOF_LONG_LONG >= 8
public static final int HAVE_LONG_LONG = 1;
// #else
// #error WHAT? sizeof(long long) < 8 ???
// #endif

/*
  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define
  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.
*/

// #if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)
// #define LONGLONG_MIN	((long long) 0x8000000000000000L)
// #define LONGLONG_MAX	((long long) 0x7FFFFFFFFFFFFFFFL)
// #endif
/* Max length needed for a buffer to hold a longlong or ulonglong + end \0 */
// #define LONGLONG_BUFFER_SIZE 21

// #if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)
/* First check for ANSI C99 definition: */
// #ifdef ULLONG_MAX
// #define ULONGLONG_MAX  ULLONG_MAX
// #else
// #define ULONGLONG_MAX ((unsigned long long)(~0L))
// #endif
// #endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/

public static final long INT_MIN64 =       (~0x7FFFFFFFFFFFFFFFL);
public static final long INT_MAX64 =       0x7FFFFFFFFFFFFFFFL;
public static final long INT_MIN32 =       (~0x7FFFFFFFL);
public static final long INT_MAX32 =       0x7FFFFFFFL;
public static final long UINT_MAX32 =      0xFFFFFFFFL;
public static final int INT_MIN24 =       (~0x007FFFFF);
public static final int INT_MAX24 =       0x007FFFFF;
public static final int UINT_MAX24 =      0x00FFFFFF;
public static final int INT_MIN16 =       (~0x7FFF);
public static final int INT_MAX16 =       0x7FFF;
public static final int UINT_MAX16 =      0xFFFF;
public static final int INT_MIN8 =        (~0x7F);
public static final int INT_MAX8 =        0x7F;
public static final int UINT_MAX8 =       0xFF;

/* From limits.h instead */
// #ifndef DBL_MIN
public static final double DBL_MIN =		4.94065645841246544e-324;
public static final double FLT_MIN =		((float)1.40129846432481707e-45);
// #endif
// #ifndef DBL_MAX
public static final double DBL_MAX =		1.79769313486231470e+308;
public static final double FLT_MAX =		((float)3.40282346638528860e+38);
// #endif
// #ifndef SIZE_T_MAX
public static final long SIZE_T_MAX =      (~((long) 0));
// #endif

/* Define missing math constants. */
// #ifndef M_PI
public static final double M_PI = 3.14159265358979323846;
// #endif
// #ifndef M_E
public static final double M_E = 2.7182818284590452354;
// #endif
// #ifndef M_LN2
public static final double M_LN2 = 0.69314718055994530942;
// #endif

/*
  Max size that must be added to a so that we know Size to make
  addressable obj.
*/
// #if SIZEOF_CHARP == 4
// #else
// #endif

// #define MY_ALIGN(A,L)	   (((A) + (L) - 1) & ~((L) - 1))
// #define MY_ALIGN_DOWN(A,L) ((A) & ~((L) - 1))
// #define ALIGN_SIZE(A)	MY_ALIGN((A),sizeof(double))
// #define ALIGN_MAX_UNIT  (sizeof(double))
/* Size to make addressable obj. */
// #define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A), sizeof(double)))
// #define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)
// #define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))
// #define PREV_BITS(type,A)	((type) (((type) 1 << (A)) -1))

/*
  Custom version of standard offsetof() macro which can be used to get
  offsets of members in class for non-POD types (according to the current
  version of C++ standard offsetof() macro can't be used in such cases and
  attempt to do so causes warnings to be emitted, OTOH in many cases it is
  still OK to assume that all instances of the class has the same offsets
  for the same members).

  This is temporary solution which should be removed once File_parser class
  and related routines are refactored.
*/

// #define my_offsetof(TYPE, MEMBER) PTR_BYTE_DIFF(&((TYPE *)0x10)->MEMBER, 0x10)

// #define NullS		(char *) 0

// #ifdef STDCALL
// #endif

// #ifdef _WIN32
// #define STDCALL __stdcall
// #else
// #define STDCALL
// #endif

/* Typdefs for easier portability */

// #ifndef HAVE_UCHAR	/* Short for unsigned char */
// #endif

// #ifndef HAVE_INT8       /* Signed integer >= 8  bits */
// #endif
// #ifndef HAVE_UINT8    /* Unsigned integer >= 8  bits */
// #endif
// #ifndef HAVE_INT16
// #endif
// #ifndef HAVE_UINT16
// #endif
// #if SIZEOF_INT == 4
// #ifndef HAVE_INT32
// #endif
// #ifndef HAVE_UINT32
// #endif
// #elif SIZEOF_LONG == 4
// #ifndef HAVE_INT32
// #endif
// #ifndef HAVE_UINT32
// #endif
// #else
// #error Neither int or long is of 4 bytes width
// #endif

// #if !defined(HAVE_ULONG) && !defined(__USE_MISC)		  /* Short for unsigned long */
// #endif
// #ifndef longlong_defined
/* 
  Using [unsigned] long long is preferable as [u]longlong because we use 
  [unsigned] long long unconditionally in many places, 
  for example in constants with [U]LL suffix.
*/
// #if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8 /* ulong or unsigned long long */
// #else	  /* ulong or unsigned long long */
// #endif
// #endif
// #ifndef HAVE_INT64
// #endif
// #ifndef HAVE_UINT64
// #endif

// #if defined(NO_CLIENT_LONG_LONG)
// #elif defined (_WIN32)
// #else
// #endif

// #if SIZEOF_CHARP == SIZEOF_INT
// #elif SIZEOF_CHARP == SIZEOF_LONG
// #elif SIZEOF_CHARP == SIZEOF_LONG_LONG
// #else
// #error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)
// #endif

// #define MY_ERRPTR ((void*)(intptr)1)

// #if defined(_WIN32)
// #else
// #if SIZEOF_OFF_T > 4
// #else
// #endif
// #endif /*_WIN32*/
// #define MY_FILEPOS_ERROR	(~(my_off_t) 0)

/*
  TODO Convert these to use Bitmap class.
 */
// Targeting global\CHARSET_INFO.java


// Targeting global\LEX_STRING.java



// #if defined(_WIN32)
// #define socket_errno	WSAGetLastError()
// #define SOCKET_EINTR	WSAEINTR
// #define SOCKET_ETIMEDOUT WSAETIMEDOUT
// #define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK
// #define SOCKET_EADDRINUSE WSAEADDRINUSE
// #define SOCKET_ECONNRESET WSAECONNRESET
// #define SOCKET_ENFILE	ENFILE
// #define SOCKET_EMFILE	EMFILE
// #define SOCKET_CLOSED   EIO
// #else /* Unix */
// #define socket_errno	errno
// #define closesocket(A)	close(A)
// #define SOCKET_EINTR	EINTR
// #define SOCKET_EAGAIN	EAGAIN
// #define SOCKET_EWOULDBLOCK EWOULDBLOCK
// #define SOCKET_EADDRINUSE EADDRINUSE
// #define SOCKET_ETIMEDOUT ETIMEDOUT
// #define SOCKET_ECONNRESET ECONNRESET
// #define SOCKET_CLOSED   EIO
// #define SOCKET_ENFILE	ENFILE
// #define SOCKET_EMFILE	EMFILE
// #endif

// #include <mysql/plugin.h>  /* my_bool */	/* Type of MyFlags in my_funcs */

// #define MYF(v)		(myf) (v)

/*
  Defines to make it possible to prioritize register assignments. No
  longer that important with modern compilers.
*/
// #ifndef USING_X
// #define reg1 register
// #define reg2 register
// #define reg3 register
// #define reg4 register
// #define reg5 register
// #define reg6 register
// #define reg7 register
// #define reg8 register
// #define reg9 register
// #define reg10 register
// #define reg11 register
// #define reg12 register
// #define reg13 register
// #define reg14 register
// #define reg15 register
// #define reg16 register
// #endif

/*
  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data
  (i.e variables) for usage in storage engine loadable plugins.
  Outside of Windows, it is dummy.
*/
// #ifndef MYSQL_PLUGIN_IMPORT
// #if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))
// #define MYSQL_PLUGIN_IMPORT __declspec(dllimport)
// #else
// #define MYSQL_PLUGIN_IMPORT
// #endif
// #endif

// #include <my_dbug.h>

/* Some helper macros */
// #define YESNO(X) ((X) ? "yes" : "no")

public static final int MY_HOW_OFTEN_TO_ALARM =	2;	/* How often we want info on screen */
public static final int MY_HOW_OFTEN_TO_WRITE =	10000;	/* How often we want info on screen */

// #include <my_byteorder.h>

// #ifdef HAVE_CHARSET_utf8mb4
public static final String MYSQL_UNIVERSAL_CLIENT_CHARSET = "utf8mb4";
// #elif defined(HAVE_CHARSET_utf8mb3)
// #else
// #endif

// #if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)
// #define NO_EMBEDDED_ACCESS_CHECKS
// #endif

// #ifdef _WIN32
// #define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)
// #define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)
// #define RTLD_DEFAULT GetModuleHandle(NULL)
// #define dlclose(lib) FreeLibrary((HMODULE)lib)

// #define HAVE_DLOPEN 1
// #define HAVE_DLERROR 1
// #endif

// #ifdef HAVE_DLFCN_H
// #include <dlfcn.h>
// #endif

// #ifdef HAVE_DLOPEN
// #else
// #define dlerror() "No support for dynamic loading (static build?)"
// #define dlopen(A,B) 0
// #define dlsym(A,B) 0
// #define dlclose(A) 0
// #define dladdr(A, B) 0
/* Dummy definition in case we're missing dladdr() */
// #endif

/*
 *  Include standard definitions of operator new and delete.
 */
// #ifdef __cplusplus
// #include <new>
// #endif

/* Length of decimal number represented by INT32. */
public static final int MY_INT32_NUM_DECIMAL_DIGITS = 11;

/* Length of decimal number represented by INT64. */
public static final int MY_INT64_NUM_DECIMAL_DIGITS = 21;

// #ifdef __cplusplus
// #include <limits> /* should be included before min/max macros */
// #endif

/* Define some useful general macros (should be done after all headers). */
// #define MY_MAX(a, b)	((a) > (b) ? (a) : (b))
// #define MY_MIN(a, b)	((a) < (b) ? (a) : (b))

// #define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)

/*
  Only Linux is known to need an explicit sync of the directory to make sure a
  file creation/deletion/renaming in(from,to) this directory durable.
*/
// #ifdef TARGET_OS_LINUX
public static final int NEED_EXPLICIT_SYNC_DIR = 1;
// #else
/*
  On linux default rwlock scheduling policy is good enough for
  waiting_threads.c, on other systems use our special implementation
  (which is slower).

  QQ perhaps this should be tested in configure ? how ?
*/
public static final int WT_RWLOCKS_USE_MUTEXES = 1;
// #endif

// #if !defined(__cplusplus) && !defined(bool)
// #define bool In_C_you_should_use_my_bool_instead()
// #endif

/* Provide __func__ macro definition for platforms that miss it. */
// #if !defined (__func__)
// #if defined(__STDC_VERSION__) && __STDC_VERSION__ < 199901L
// #  if __GNUC__ >= 2
// #    define __func__ __FUNCTION__
// #  else
// #    define __func__ "<unknown>"
// #  endif
// #elif defined(_MSC_VER)
// #  if _MSC_VER < 1300
// #    define __func__ "<unknown>"
// #  else
// #    define __func__ __FUNCTION__
// #  endif
// #elif defined(__BORLANDC__)
// #  define __func__ __FUNC__
// #else
// #  define __func__ "<unknown>"
// #endif
// #endif /* !defined(__func__) */

/* Defines that are unique to the embedded version of MySQL */

// #ifdef EMBEDDED_LIBRARY

/* Things we don't need in the embedded version of MySQL */
/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */

// #else
// #define HAVE_REPLICATION
// #define HAVE_EXTERNAL_CLIENT
// #endif /* EMBEDDED_LIBRARY */

/*
  Provide defaults for the CPU cache line size, if it has not been detected by
  CMake using getconf
*/
// #if !defined(CPU_LEVEL1_DCACHE_LINESIZE) || CPU_LEVEL1_DCACHE_LINESIZE == 0
//   #if defined(CPU_LEVEL1_DCACHE_LINESIZE) && CPU_LEVEL1_DCACHE_LINESIZE == 0
//     #undef CPU_LEVEL1_DCACHE_LINESIZE
//   #endif

//   #if defined(__s390__)
    public static final int CPU_LEVEL1_DCACHE_LINESIZE = 256;
//   #elif defined(__powerpc__) || defined(__aarch64__)
//   #else
//   #endif
// #endif

public static final int FLOATING_POINT_DECIMALS = 31;

/* Keep client compatible with earlier versions */
// #ifdef MYSQL_SERVER
// #define NOT_FIXED_DEC           DECIMAL_NOT_SPECIFIED
// #else
// #define NOT_FIXED_DEC           FLOATING_POINT_DECIMALS
// #endif
// #endif /* my_global_h */


// Parsed from mysql_time.h

/* Copyright (c) 2004, 2006 MySQL AB
   Use is subject to license terms

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; version 2 of the License.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA */

// #ifndef _mysql_time_h_
// #define _mysql_time_h_

/*
  Portable time_t replacement.
  For 32 bit systems holds seconds for 1970 - 2038-01-19
  For 64 bit systems holds seconds for 1970 - 2106-02-07

  Using the system built in time_t is not an option as
  we rely on the above requirements in the time functions   
*/

// #ifndef MYSQL_ABI_CHECK
/*
  long is 64bit on all 64bit systems, except Windows where it is 32 bit.
  long is 32bit on all 32bit systems.
  The following code ensures that my_time_t is 64 bit on all 64 bit
  systems.
*/
// #ifdef _WIN64
// #else
// #endif
// #endif /* MYSQL_ABI_CHECK */

/*
  Time declarations shared between the server and client API:
  you should not add anything to this header unless it's used
  (and hence should be visible) in mysql.h.
  If you're looking for a place to add new time-related declaration,
  it's most likely my_time.h. See also "C API Handling of Date
  and Time Values" chapter in documentation.
*/

public enum enum_mysql_timestamp_type {
  MYSQL_TIMESTAMP_NONE(-2), MYSQL_TIMESTAMP_ERROR(-1),
  MYSQL_TIMESTAMP_DATE(0), MYSQL_TIMESTAMP_DATETIME(1), MYSQL_TIMESTAMP_TIME(2);

    public final int value;
    private enum_mysql_timestamp_type(int v) { this.value = v; }
    private enum_mysql_timestamp_type(enum_mysql_timestamp_type e) { this.value = e.value; }
    public enum_mysql_timestamp_type intern() { for (enum_mysql_timestamp_type e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting global\MYSQL_TIME.java



// #endif /* _mysql_time_h_ */


// Parsed from my_list.h

/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */

// #ifndef _list_h_
// #define _list_h_

// #ifdef	__cplusplus
// Targeting global\LIST.java


// Targeting global\list_walk_action.java











// #define list_rest(a) ((a)->next)
// #define list_push(a,b) (a)=list_cons((b),(a))
// #define list_pop(A) {LIST *old=(A); (A)=list_delete(old,old); my_free(old); }

// #ifdef	__cplusplus
// #endif
// #endif


// Parsed from my_alloc.h

/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */

/* 
   Data structures for mysys/my_alloc.c (root memory allocator)
*/

// #ifndef _my_alloc_h
// #define _my_alloc_h

// #include "mysql/psi/psi_base.h"

public static final int ALLOC_MAX_BLOCK_TO_DROP =			4096;
public static final int ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP =	10;

public static final int ROOT_FLAG_READ_ONLY =       4;

// #ifdef __cplusplus
// #endif
// Targeting global\MEM_ROOT.java



// #ifdef  __cplusplus
// #endif

// #endif


// Parsed from ext_mysql_data.h

// #ifndef _H_EXT_MYDATA
// #define _H_EXT_MYDATA

// #include<stdio.h>
// #include<stdlib.h>

/**
 Allocate a array with type char* (as type char**)
*/
public static native @Cast("char**") PointerPointer ext_alloc_char_list(int length);

/**
 Add char* element into char** array
*/
public static native int ext_char_list_insert(@Cast("char**") PointerPointer buf,@Cast("char*") BytePointer str, int idx);
public static native int ext_char_list_insert(@Cast("char**") @ByPtrPtr BytePointer buf,@Cast("char*") BytePointer str, int idx);
public static native int ext_char_list_insert(@Cast("char**") @ByPtrPtr ByteBuffer buf,@Cast("char*") ByteBuffer str, int idx);
public static native int ext_char_list_insert(@Cast("char**") @ByPtrPtr byte[] buf,@Cast("char*") byte[] str, int idx);

/**
 Get char* element from char** array
*/
public static native @Cast("char*") BytePointer ext_char_list_get(@Cast("char**") PointerPointer buf, int idx);
public static native @Cast("char*") BytePointer ext_char_list_get(@Cast("char**") @ByPtrPtr BytePointer buf, int idx);
public static native @Cast("char*") ByteBuffer ext_char_list_get(@Cast("char**") @ByPtrPtr ByteBuffer buf, int idx);
public static native @Cast("char*") byte[] ext_char_list_get(@Cast("char**") @ByPtrPtr byte[] buf, int idx);

public static native void ext_char_list_free(@Cast("char**") PointerPointer buf);
public static native void ext_char_list_free(@Cast("char**") @ByPtrPtr BytePointer buf);
public static native void ext_char_list_free(@Cast("char**") @ByPtrPtr ByteBuffer buf);
public static native void ext_char_list_free(@Cast("char**") @ByPtrPtr byte[] buf);

public static native void ext_error_print(@Cast("char*") BytePointer str);
public static native void ext_error_print(@Cast("char*") ByteBuffer str);
public static native void ext_error_print(@Cast("char*") byte[] str);

// #endif


}
