// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.swdc.imgui.core.imgui;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.swdc.imgui.core.ImGUICore.*;


// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//  scale using lists with tens of thousands of items without a problem)
// Usage:
//   ImGuiListClipper clipper;
//   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//   while (clipper.Step())
//       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//           ImGui::Text("line number %d", i);
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
@Properties(inherit = org.swdc.imgui.conf.ImGuiCoreConfigure.class)
public class ImGuiListClipper extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ImGuiListClipper() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ImGuiListClipper(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImGuiListClipper(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ImGuiListClipper position(long position) {
        return (ImGuiListClipper)super.position(position);
    }
    @Override public ImGuiListClipper getPointer(long i) {
        return new ImGuiListClipper((Pointer)this).offsetAddress(i);
    }

    public native ImGuiContext Ctx(); public native ImGuiListClipper Ctx(ImGuiContext setter);               // Parent UI context
    public native int DisplayStart(); public native ImGuiListClipper DisplayStart(int setter);      // First item to display, updated by each call to Step()
    public native int DisplayEnd(); public native ImGuiListClipper DisplayEnd(int setter);        // End of items to display (exclusive)
    public native int ItemsCount(); public native ImGuiListClipper ItemsCount(int setter);        // [Internal] Number of items
    public native float ItemsHeight(); public native ImGuiListClipper ItemsHeight(float setter);       // [Internal] Height of item after a first step and item submission can calculate it
    public native float StartPosY(); public native ImGuiListClipper StartPosY(float setter);         // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
    public native double StartSeekOffsetY(); public native ImGuiListClipper StartSeekOffsetY(double setter);  // [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.
    public native Pointer TempData(); public native ImGuiListClipper TempData(Pointer setter);          // [Internal] Internal data
}
