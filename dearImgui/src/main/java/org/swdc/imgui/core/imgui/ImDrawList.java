// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.swdc.imgui.core.imgui;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.swdc.imgui.core.ImGUICore.*;


// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix to want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
@Properties(inherit = org.swdc.imgui.conf.ImGuiCoreConfigure.class)
public class ImDrawList extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ImDrawList() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ImDrawList(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImDrawList(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ImDrawList position(long position) {
        return (ImDrawList)super.position(position);
    }
    @Override public ImDrawList getPointer(long i) {
        return new ImDrawList((Pointer)this).offsetAddress(i);
    }

    // This is what you have to render
    public native @ByRef ImVector_ImDrawCmd CmdBuffer(); public native ImDrawList CmdBuffer(ImVector_ImDrawCmd setter);        // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
    public native @ByRef ImVector_ImDrawIdx IdxBuffer(); public native ImDrawList IdxBuffer(ImVector_ImDrawIdx setter);        // Index buffer. Each command consume ImDrawCmd::ElemCount of those
    public native @ByRef ImVector_ImDrawVert VtxBuffer(); public native ImDrawList VtxBuffer(ImVector_ImDrawVert setter);        // Vertex buffer.
    public native @Cast("ImDrawListFlags") int Flags(); public native ImDrawList Flags(int setter);            // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

    // [Internal, used while building lists]
    public native @Cast("unsigned int") int _VtxCurrentIdx(); public native ImDrawList _VtxCurrentIdx(int setter);   // [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
    public native ImDrawListSharedData _Data(); public native ImDrawList _Data(ImDrawListSharedData setter);            // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
    public native ImDrawVert _VtxWritePtr(); public native ImDrawList _VtxWritePtr(ImDrawVert setter);     // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    public native @Cast("ImDrawIdx*") ShortPointer _IdxWritePtr(); public native ImDrawList _IdxWritePtr(ShortPointer setter);     // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
    public native @ByRef ImVector_ImVec2 _Path(); public native ImDrawList _Path(ImVector_ImVec2 setter);            // [Internal] current path building
    public native @ByRef ImDrawCmdHeader _CmdHeader(); public native ImDrawList _CmdHeader(ImDrawCmdHeader setter);       // [Internal] template of active commands. Fields should match those of CmdBuffer.back().
    public native @ByRef ImDrawListSplitter _Splitter(); public native ImDrawList _Splitter(ImDrawListSplitter setter);        // [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
    public native @ByRef ImVector_ImVec4 _ClipRectStack(); public native ImDrawList _ClipRectStack(ImVector_ImVec4 setter);   // [Internal]
    public native @ByRef ImVector_ImTextureID _TextureIdStack(); public native ImDrawList _TextureIdStack(ImVector_ImTextureID setter);  // [Internal]
    public native float _FringeScale(); public native ImDrawList _FringeScale(float setter);     // [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
    public native @Cast("const char*") BytePointer _OwnerName(); public native ImDrawList _OwnerName(BytePointer setter);       // Pointer to owner window's name for debugging

    // Obsolete names
    //inline  void  AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { AddEllipse(center, ImVec2(radius_x, radius_y), col, rot, num_segments, thickness); } // OBSOLETED in 1.90.5 (Mar 2024)
    //inline  void  AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { AddEllipseFilled(center, ImVec2(radius_x, radius_y), col, rot, num_segments); }                        // OBSOLETED in 1.90.5 (Mar 2024)
    //inline  void  PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { PathEllipticalArcTo(center, ImVec2(radius_x, radius_y), rot, a_min, a_max, num_segments); } // OBSOLETED in 1.90.5 (Mar 2024)
    //inline  void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); } // OBSOLETED in 1.80 (Jan 2021)
    //inline  void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); } // OBSOLETED in 1.80 (Jan 2021)
}
